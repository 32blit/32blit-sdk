#pragma once

#include <cstdint>

#include "../32blit.hpp"
#include "../types/size.hpp"
#include "../types/point.hpp"
#include "../types/mat3.hpp"

namespace blit {

  enum TMXFlags {
    TMX_16BIT      = (1 << 0), /// tile data is 16-bit
    TMX_TRANSFORMS = (1 << 1)  /// transform data is included after the tile data
  };

  /// struct header generated by the `output_struct` option
  #pragma pack(push,1)
  struct TMX {
      char head[4];
      uint16_t header_length;
      uint16_t flags;
      uint16_t empty_tile;
      uint16_t width;
      uint16_t height;
      uint16_t layers;
      uint8_t data[];
  };
  #pragma pack(pop)


  // A `tilemap` describes a grid of tiles with optional transforms
  struct TileMap {
    Size          bounds;

    uint8_t      *tiles;
    uint8_t      *transforms;
    Surface  *sprites;
    Mat3          transform = Mat3::identity();

    enum {
      NONE = 0,           // draw nothing
      REPEAT = 1,         // infinite repeat
      DEFAULT_FILL = 2,   // fill with default tile
      CLAMP_TO_EDGE = 3,  // repeats the tile at the edge
    } repeat_mode = NONE; // determines what to do when drawing outside of the layer bounds.
    uint8_t       default_tile_id;

    int empty_tile_id = -1;

    int load_flags = 0;

    enum LoadFlags {
      COPY_TILES = (1 << 0),
      COPY_TRANSFORMS = (1 << 1)
    };

    TileMap(uint8_t *tiles, uint8_t *transforms, Size bounds, Surface *sprites);
    virtual ~TileMap();

    static TileMap *load_tmx(const uint8_t *asset, Surface *sprites, int layer = 0, int flags = COPY_TILES | COPY_TRANSFORMS);

    inline int32_t offset(const Point &p) {return offset(p.x, p.y);} // __attribute__((always_inline));
    int32_t offset(int16_t x, int16_t y); // __attribute__((always_inline));
    uint8_t tile_at(const Point &p); // __attribute__((always_inline));
    uint8_t transform_at(const Point &p); // __attribute__((always_inline));

    void draw(Surface *dest, Rect viewport, std::function<Mat3(uint8_t)> scanline_callback = nullptr);

  //  void mipmap_texture_span(surface *dest, point s, uint16_t c, vec2 swc, vec2 ewc);
    void texture_span(Surface *dest, Point s, unsigned int c, Vec2 swc, Vec2 ewc);
  };

  /// Multi-layered tile map
  class TiledMap {
  public:
      enum LoadFlags {
      COPY_TILES = (1 << 0),
      COPY_TRANSFORMS = (1 << 1)
    };
    
    TiledMap(Size bounds, unsigned num_layers, Surface *sprites);
    TiledMap(const uint8_t *asset, Surface *sprites, int flags = COPY_TILES | COPY_TRANSFORMS);

    virtual ~TiledMap();

    /// Draw map to `screen`
    void draw() {draw(&screen, Rect({0, 0}, screen.bounds));}

    void draw(Surface *dest, Rect viewport);

    void draw(std::function<Mat3(uint8_t)> scanline_callback) {draw(&screen, Rect({0, 0}, screen.bounds), scanline_callback);}
    void draw(Surface *dest, Rect viewport, std::function<Mat3(uint8_t)> scanline_callback);

    unsigned get_num_layers() const {return num_layers;}

    TileMap *get_layer(unsigned index);

    Size get_bounds() const;

    void set_scroll_position(Point scroll_position);
    void set_scroll_position(unsigned layer, Point scroll_position);

    void set_transform(Mat3 transform);
    void set_transform(unsigned layer, Mat3 transform);

  private:
    unsigned num_layers = 0;
    TileMap **layers;
  };

}
