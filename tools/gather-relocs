#!/usr/bin/env python3

import struct
import sys

from elftools.elf.elffile import ELFFile
from elftools.elf.enums import ENUM_RELOC_TYPE_ARM
from elftools.elf.relocation import RelocationSection

elf_filename = sys.argv[1]
bin_filename = sys.argv[2]
out_filename = sys.argv[3]

with open(elf_filename, 'rb') as f:
    elffile = ELFFile(f)

    reloc_offsets = []

    # find sidata/sdata
    sidata = 0
    sdata = 0
    relocs = elffile.get_section_by_name('.rel.text')
    symtable = elffile.get_section(relocs['sh_link'])
    for reloc in relocs.iter_relocations():
        symbol = symtable.get_symbol(reloc['r_info_sym'])
        if symbol.name == '_sidata':
            sidata = symbol['st_value']
        elif symbol.name == '_sdata':
            sdata = symbol['st_value']

        if sidata and sdata:
            break

    assert(sidata != 0 and sdata != 0)

    # get all .data relocations
    relocs = elffile.get_section_by_name('.rel.data')
    symtable = elffile.get_section(relocs['sh_link'])

    for reloc in relocs.iter_relocations():
        symbol = symtable.get_symbol(reloc['r_info_sym'])

        if reloc['r_info_type'] != ENUM_RELOC_TYPE_ARM['R_ARM_ABS32']:
            continue

        # doesn't point to flash
        if symbol['st_value'] < 0x90000000:
            continue

        # map RAM address back to flash
        flash_offset = (reloc['r_offset'] - sdata) + sidata
        print("{:08X} -> {:08X}".format(reloc['r_offset'], flash_offset))

        assert((flash_offset & 3) == 0)

        reloc_offsets.append(flash_offset)

    with open(out_filename, 'wb') as out_f:
        out_f.write(b"RELO")
        out_f.write(struct.pack("<L", len(reloc_offsets)))
        for off in reloc_offsets:
            out_f.write(struct.pack("<L", off))

        out_f.write(open(bin_filename, 'rb').read())
